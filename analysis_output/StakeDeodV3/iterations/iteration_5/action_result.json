{
  "vulnerability_found": true,
  "vulnerability_type": "Referral Bonus Manipulation and Accounting Inconsistency",
  "attack_scenario": "An attacker controlling multiple accounts can abuse the way referral bonuses are credited. The contract uses two mutually exclusive branches (one updating users[referrer].referalEarning and one updating stakeReferal[referrer]) based on two different ways of checking if the referrer \u2018has staked\u2019. Since both sources of bonus are added in the withdrawal calculation, an attacker can \u201cdouble\u2010dip\u201d by ensuring that for different deposits the same referrer receives bonus credit in separate storage locations. In addition, the referral bonus is not subject to a vesting (time lock) mechanism, so while the deposited amounts are released gradually by schedule, the bonus is available immediately once credited.",
  "exploit_code": "// Pseudo-transaction sequence (each transaction is executed by different attacker-controlled EOAs)\n\n// STEP 1: Set up a referrer account A that qualifies as 'staked'\n// Account A stakes a (minimal) amount to set userStakedStatus[A] = true.\n// Transaction from A:\nstakeTokens(A, minimalAmount, someReferrer, stakingPeriod)\n\n// STEP 2: Use attacker-controlled accounts B and C (and potentially many more) to deposit tokens using A as their referrer.\n// For deposit from account B:\n// Transaction from B:\nstakeTokens(B, X, A, chosenShortStakingPeriod)\n// => The contract checks: since A is already marked as staked (userStakedStatus[A]==true) and B != A, bonus is computed\n//    bonus1 = ( X * getReferalBonusFromDays[chosenShortStakingPeriod] ) / 1000 and is added to users[A].referalEarning\n\n// For deposit from account C:\n// Transaction from C:\nstakeTokens(C, Y, A, chosenShortStakingPeriod)\n// => Alternatively, if the external call checkUserStakedStatus returns true but for some reason the on-chain flag was toggled (or by using another deposit that forces use of the else-if branch), bonus is computed as\n//    bonus2 = ( Y * getReferalBonusFromDays[chosenShortStakingPeriod] ) / 1000 and is added to stakeReferal[A]\n\n// (The attacker can further alternate or use additional attacker-controlled depositors so that in aggregate account A gets credit in both referal bonus storage locations.)\n\n// STEP 3: After the deposits, account A calls withdrawTokens to claim its available funds. The availableAmountForClaim(user) function sums all amounts released from deposits and adds the bonus from (users[A].referalEarning + stakeReferal[A]). Since the bonus is not time locked, even if the deposit amount from accounts B, C, etc. is still vesting, the bonus sits in A\u2019s claimable balance immediately.\n// Transaction from A:\nwithdrawTokens(A)\n\n// As a result, account A receives bonus tokens (which have not been \u201cbacked\u201d by a matching vesting schedule) in addition to any tokens released from a deposit if applicable, effectively earning extra tokens with no corresponding commitment.",
  "profit_mechanism": "For every deposit made using the attacker-controlled referral account A, a bonus is computed as a fixed percentage of the deposit (i.e. bonus = depositAmount * referralBonusPercentage/1000). Because the bonus is credited in full (and in one or two separate storages) and then added immediately to the withdrawable amount, the attacker essentially receives extra tokens \u201cfor free\u201d relative to the sum of tokens actually locked. In a realistic example, if an attacker deposits 100 tokens from account B and 100 tokens from account C with a referral bonus percentage set to 100 (10%), then account A eventually collects 10 tokens bonus for each deposit (10 + 10 = 20 tokens extra) without having to lock up additional capital.",
  "attack_prerequisites": "1. The attacker must control multiple accounts (EOAs) and have a pre\u2011staked referrer account (account A) so that userStakedStatus[A] is true. 2. The referral bonus percentages (admin\u2010controlled parameters) must be set to a non\u2011zero value. 3. The attacker must be able to provide deposits from other accounts (B, C, \u2026) that reference A as the referrer. 4. The external dependency checkUserStakedStatus must return a value that supports triggering both bonus-credit branches (or the attacker must be able to alternate inputs such that bonus credit is applied in both storage locations.",
  "attack_limitations": "\u2022 The attacker must front-load some funds to make the deposits (even if minimal amounts) to trigger the bonus credit. \u2022 The overall profit margin depends on the admin\u2011controlled referral bonus percentage; if set too low the profit might be marginal. \u2022 If the contract is later updated to add a vesting or one\u2011time claim mechanism for bonuses, the attack may be prevented. \u2022 If admin or governance intervention disables the referral feature or corrects the bonus accumulation, the attack no longer works.",
  "edge_cases": "\u2022 If all referrals are forced into a single bonus accounting branch (i.e. only users[referrer].referalEarning is used) there may be less opportunity for accumulating double bonus across separate mappings. \u2022 If the staking period enforced for deposits is long, attackers may be forced to wait for sufficient bonus withdrawal even though the bonus itself is unlocked. However, since bonus is added on top of vesting deposits and is available immediately, this does not fully mitigate the attack. \u2022 If additional checks are later implemented to prevent self\u2011funding of referral systems, the attack vector would be closed.",
  "confidence": "high",
  "reasons_if_not_feasible": "",
  "reasoning": "Step\u2010by\u2010step, the attacker sets up an account (A) that is eligible for receiving referral bonuses by staking a minimal amount. Then, using other accounts (B, C, etc.), the attacker makes deposits and deliberately specifies A as the referrer. Depending on conditions (either the on-chain flag userStakedStatus for A or via the external checkUserStakedStatus), the bonus is credited either to users[A].referalEarning or to stakeReferal[A]. Both values are later summed in availableAmountForClaim with no separate vesting check, so A can claim the entire bonus immediately. The deposited tokens (from B, C, etc.) are just a means to trigger bonus calculation \u2013 since the attacker controls them, the overall extra bonus received from A is a net profit provided that the sum of bonus tokens exceeds any cost (or opportunity cost) of those deposits. This sequence is executable in practice provided that the admin-controlled percentages are non\u2011zero and the external check does not impose additional restrictions. Thus, the attacker can withdraw more tokens (bonus) than expected relative to the amount locked.",
  "analysis_metadata": {
    "iteration": 4,
    "variables_analyzed": [
      "depositInfo[*].depositAmount",
      "users[_userAddress].referalEarning",
      "depositInfo[*].depositedTimestamp",
      "depositInfo[*].timePeriodInDays",
      "stakeReferal"
    ],
    "dependencies_analyzed": [
      "IERC20.safeTransfer",
      "IERC20.safeTransferFrom",
      "checkUserStakedStatus",
      "stakeTokensV3",
      "availableAmountForClaim"
    ]
  }
}